xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern x86-based multiprocessor using ANSI C.

ACKNOWLEDGMENTS

xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
2000)). See also https://pdos.csail.mit.edu/6.828/, which
provides pointers to on-line resources for v6.

xv6 borrows code from the following sources:
    JOS (asm.h, elf.h, mmu.h, bootasm.S, ide.c, console.c, and others)
    Plan 9 (entryother.S, mp.h, mp.c, lapic.c)
    FreeBSD (ioapic.c)
    NetBSD (console.c)

The following people have made contributions: Russ Cox (context switching,
locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
Clements.

We are also grateful for the bug reports and patches contributed by Silas
Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel Filardo, Peter
Froehlich, Yakir Goaron,Shivam Handa, Bryan Henry, Jim Huang, Alexander
Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller, Eddie Kohler, Austin
Liew, Imbar Marinescu, Yandong Mao, Matan Shabtay, Hitoshi Mitake, Carmi
Merimovich, Mark Morrissey, mtasm, Joel Nider, Greg Price, Ayan Shafqat,
Eldar Sehayek, Yongming Shen, Cam Tenny, tyfkda, Rafael Ubal, Warren
Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi Watanabe, Nicolas
Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng, and Zou Chang Wei.

The code in the files that constitute xv6 is
Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.

ERROR REPORTS

We switched our focus to xv6 on RISC-V; see the mit-pdos/xv6-riscv.git
repository on github.com.

BUILDING AND RUNNING XV6




Home work assignment hw05 for os course:
Your MLQ scheduler must follow these rules:
• There should be three priority levels, numbered from 2 (highest) down to 0 
(lowest). At creation, a process starts with priority 1.
• Whenever the xv6 timer tick occurs (by default this happens every 10 ms), 
the highest priority process which is ready (‘RUNNABLE’) is scheduled to run.
That is, this is a preemptive scheduler. 
• The highest priority ready process is scheduled to run whenever the 
previously running process exits, sleeps, or otherwise ‘yields’ the CPU.
• Your scheduler should schedule all the processes at each priority level in a 
round robin fashion.
• When a timer tick occurs, whichever process was currently using the CPU should be 
considered to have used up an entire timer tick's worth of CPU, even if it did not 
start at the previous tick (note that a timer tick is different than the time-slice)
• time slices: (priority, ticks in time slice) -> (0,32), (1,16), (2, 8)
• If a process voluntarily relinquishes the CPU before its time-slice expires at a 
particular priority level, its time-slice is reset; the next time that that process 
is scheduled, it will have a new time-slice at that priority level.
• A process in a given priority completes its time slice before other processes 
in the same priority can run. In other words, a new process will not preempt
the running process in this priority. The running process will stop running if 
preempted by a higher priority process, or it relinquish (i.e. give away) the 
CPU.
Furthermore, to implement a setpriority system call to set the current process priority and a user space function 
that will call the system call:
/**
set the current process priority (0..2)
 @return 0 if success, non zero if error
**/
int set_priority(int new_priority);


To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
will need to install a cross-compiler gcc suite capable of producing
x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
simulator and run "make qemu".
